document.addEventListener('DOMContentLoaded', () => {
    const grid = document.getElementById('grid');
    const scoreDisplay = document.getElementById('score');
    const startButton = document.getElementById('start-button');
    const width = 10;
    const height = 20;
    let squares = [];
    let currentPosition = 4;
    let currentRotation = 0;
    let score = 0;
    let timerId;
    let isGameOver = false;

    // --- 1. 격자 생성 ---
    for (let i = 0; i < width * height; i++) {
        const square = document.createElement('div');
        square.classList.add('square');
        grid.appendChild(square);
        squares.push(square);
    }
    // 바닥과 경계선 역할을 할 'taken' 블록 10개 추가 (보이지 않게)
    for (let i = 0; i < width; i++) {
        const square = document.createElement('div');
        square.classList.add('square', 'taken');
        grid.appendChild(square);
        squares.push(square);
    }

    // --- 2. 블록 정의 (Tetrominoes) ---
    // 각 블록의 4가지 회전 상태를 정의합니다. (index는 currentPosition 기준 상대 위치)
    const iTetromino = [
        [1, width + 1, width * 2 + 1, width * 3 + 1],
        [width, width + 1, width + 2, width + 3],
        [1, width + 1, width * 2 + 1, width * 3 + 1],
        [width, width + 1, width + 2, width + 3]
    ];
    
    // J, L, O, S, T, Z 블록 정의 (중략: 코드의 간결성을 위해 일부 생략)
    // 실제 사용 시, 모든 블록의 정의가 필요합니다.

    const theTetrominoes = [iTetromino, /* J, L, O, S, T, Z 블록 추가 */];
    const colors = ['i', 'j', 'l', 'o', 's', 't', 'z']; // style.css의 클래스 이름과 일치

    let random = Math.floor(Math.random() * theTetrominoes.length);
    let current = theTetrominoes[random][currentRotation];
    let currentClass = colors[random];

    // --- 3. 블록 그리기 및 지우기 ---
    function draw() {
        current.forEach(index => {
            // 경계를 벗어나지 않는지 확인 후 그림
            if (squares[currentPosition + index]) {
                squares[currentPosition + index].classList.add('tetromino', currentClass);
            }
        });
    }

    function undraw() {
        current.forEach(index => {
            if (squares[currentPosition + index]) {
                squares[currentPosition + index].classList.remove('tetromino', currentClass);
            }
        });
    }

    // --- 4. 충돌 검사 및 고정 ---
    function checkCollision(nextPos) {
        return current.some(index => {
            const nextSquareIndex = currentPosition + nextPos + index;
            // 다음 위치가 'taken' 클래스를 가졌거나, 배열 범위를 벗어나면 충돌
            return squares[nextSquareIndex] && squares[nextSquareIndex].classList.contains('taken');
        });
    }

    function moveDown() {
        if (!timerId || isGameOver) return;

        undraw();
        if (!checkCollision(width)) {
            currentPosition += width;
        } else {
            freeze(); // 충돌 발생 시 블록 고정
        }
    }
    
    function freeze() {
        current.forEach(index => squares[currentPosition + index].classList.add('taken'));
        
        addScore();
        
        // 새 블록 생성
        random = Math.floor(Math.random() * theTetrominoes.length);
        currentRotation = 0;
        current = theTetrominoes[random][currentRotation];
        currentClass = colors[random];
        currentPosition = 4;
        
        checkGameOver();
        draw();
    }

    // --- 5. 블록 이동 (좌우) 및 회전 (이동/회전 로직 생략: 복잡하며 위 코드와 유사) ---
    function moveLeft() { /* ... 로직 구현 ... */ }
    function moveRight() { /* ... 로직 구현 ... */ }
    function rotate() { /* ... 로직 구현 ... */ }

    // --- 6. 점수 계산 및 줄 제거 ---
    function addScore() {
        for (let i = 0; i < height * width; i += width) {
            const row = [];
            for (let j = 0; j < width; j++) {
                row.push(i + j);
            }

            // 한 줄이 모두 'taken'이라면
            if (row.every(index => squares[index].classList.contains('taken'))) {
                score += 10;
                scoreDisplay.innerHTML = '점수: ' + score;

                // 줄 제거 및 DOM 업데이트 로직 (위 코드와 유사)
                row.forEach(index => {
                    squares[index].classList.remove('taken', 'tetromino', ...colors);
                });
                const squaresRemoved = squares.splice(i, width); 
                squares = squaresRemoved.concat(squares);
                squares.forEach(cell => grid.appendChild(cell));
            }
        }
    }

    // --- 7. 게임 오버 ---
    function checkGameOver() {
        // 새 블록이 생성될 자리가 이미 'taken'이면 게임 오버
        if (current.some(index => squares[currentPosition + index].classList.contains('taken'))) {
            scoreDisplay.innerHTML = `GAME OVER! 최종 점수: ${score}`;
            clearInterval(timerId);
            timerId = null;
            isGameOver = true;
            startButton.innerHTML = '재시작';
        }
    }

    // --- 8. 컨트롤 이벤트 리스너 ---
    document.addEventListener('keydown', (e) => {
        if (timerId && !isGameOver) {
            if (e.key === 'ArrowLeft') moveLeft();
            else if (e.key === 'ArrowUp') rotate();
            else if (e.key === 'ArrowRight') moveRight();
            else if (e.key === 'ArrowDown') moveDown();
        }
    });

    // 버튼 이벤트 연결 (모바일/터치용)
    document.getElementById('rotate').addEventListener('click', rotate);
    document.getElementById('left').addEventListener('click', moveLeft);
    document.getElementById('right').addEventListener('click', moveRight);
    document.getElementById('down').addEventListener('click', moveDown);

    // 시작/일시정지 버튼
    startButton.addEventListener('click', () => {
        if (isGameOver) {
            location.reload(); 
            return;
        }
        
        if (timerId) {
            clearInterval(timerId);
            timerId = null;
            startButton.innerHTML = '재개';
        } else {
            draw();
            timerId = setInterval(moveDown, 1000); // 1초마다 아래로 이동
            startButton.innerHTML = '일시정지';
        }
    });
});
